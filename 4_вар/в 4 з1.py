import numpy as np

# Данные из таблицы
r = np.array([0.6, 1.5, 1.5, 1.5, 1.1, 0.9, 0.7, 1.0, 0.6, 1.2])  # Ом
i = np.array([3.7, 3.1, 3.4, 3.2, 3.7, 4.1, 2.8, 2.8, 3.9, 3.5])  # А

# Создаем вектор из 1 для умножения (матричный подход для суммы)
# Сумма обратных сопротивлений: 1^T * (1/r)
ones = np.ones(len(r))  # вектор из единиц
inv_r = 1 / r  # вектор обратных сопротивлений

# Матричное умножение для суммы: вектор-строка * вектор-столбец
inv_R_total = ones @ inv_r  # или np.dot(ones, inv_r)
R_eq = 1 / inv_R_total

# Общий ток: 1^T * i (матричное представление суммы)
I_total = ones @ i

U = I_total * R_eq

# Нумерация в задаче с 1, в Python индексы с 0
R1 = r[2]  # 1.5 Ом (резистор 3)
R2 = r[8]  # 0.6 Ом (резистор 9)
U1 = 1.4  # В
U2 = 1.0  # В

# Создаем векторы для последовательной цепи
R_vec = np.array([R1, R2])
U_vec = np.array([U1, U2])

# Общее сопротивление: сумма элементов вектора R_vec
R_total = np.sum(R_vec)  # или ones_2 @ R_vec где ones_2 = [1, 1]

# Общее напряжение: сумма элементов вектора U_vec
U_total = np.sum(U_vec)  # или ones_2 @ U_vec

# Ток через матричные операции
ones_2 = np.ones(2)  # вектор из двух единиц
I_series = (ones_2 @ U_vec) / (ones_2 @ R_vec)

# Итоговые результаты
print("\n=== Итоговые результаты ===")
print(f"1. Эквивалентное сопротивление R = {R_eq:.4f} Ом")
print(f"2. Общий ток I = {I_total} А")
print(f"3. Напряжение U = {U:.4f} В")
print(f"4. Ток в последовательной цепи I = {I_series:.4f} А")
